# RFC-001: jq 语法兼容性分析

**状态**: 已实现 (Implemented)
**作者**: XQPath 项目组
**创建日期**: 2025 年 7 月
**最后更新**: 2025 年 7 月 27 日

## 摘要

本 RFC 分析了 XQPath 与 jq 的语法兼容性，确定了优先级和实现路径。目标是在保持简洁性的同时，提供最大程度的 jq 语法兼容性。

## 动机

jq 是 JSON 数据处理的事实标准，拥有丰富的语法和广泛的用户基础。XQPath 作为 Rust 生态中的替代方案，需要提供足够的 jq 兼容性来降低用户学习成本，同时保持 Rust 的性能优势。

## 详细设计

### 功能覆盖现状

#### 🟢 已支持的语法（XQPath 1.2）

| 语法分类       | XQPath 语法          | jq 等价语法          | 支持状态 | 描述         |
| -------------- | -------------------- | -------------------- | -------- | ------------ |
| **基础访问**   | `.field`             | `.field`             | ✅       | 字段访问     |
| **数组索引**   | `[0]`                | `[0]`                | ✅       | 数组元素访问 |
| **通配符**     | `*`                  | `.[]`                | ✅       | 迭代所有元素 |
| **递归访问**   | `**`                 | `..`                 | ✅       | 递归下降匹配 |
| **类型过滤**   | `\| string`          | `\| strings`         | ✅       | 基础类型过滤 |
| **管道操作**   | `\|`                 | `\|`                 | ✅       | 数据流管道   |
| **逗号操作**   | `,`                  | `,`                  | ✅       | 多路输出     |
| **条件表达式** | `if-then-else`       | `if-then-else`       | ✅       | 条件分支     |
| **比较操作**   | `==`, `!=`, `<`, `>` | `==`, `!=`, `<`, `>` | ✅       | 数值比较     |
| **逻辑操作**   | `and`, `or`, `not`   | `and`, `or`, `not`   | ✅       | 布尔逻辑     |
| **错误处理**   | `try-catch`, `.?`    | `try-catch`, `.?`    | ✅       | 错误抑制     |

#### 🟡 部分支持的功能

| jq 语法分组    | 支持程度 | XQPath 实现                                | 备注           |
| -------------- | -------- | ------------------------------------------ | -------------- |
| **内置函数**   | 60%      | `length()`, `type()`, `keys()`, `values()` | 基础函数已实现 |
| **高级函数**   | 40%      | `map()`, `select()`, `sort()`, `unique()`  | 核心函数已实现 |
| **数据构造**   | 80%      | `{}`, `[]`, 字面量                         | 基本构造支持   |
| **字符串操作** | 10%      | 基础字符串字面量                           | 待扩展         |

#### 🔴 待实现的功能（v1.3+）

| jq 语法分类    | jq 语法             | 功能描述       | 计划版本 |
| -------------- | ------------------- | -------------- | -------- |
| **用户函数**   | `def func():`       | 用户自定义函数 | v1.3     |
| **变量绑定**   | `as $var`           | 变量系统       | v1.3     |
| **模块系统**   | `import`, `include` | 代码重用       | v1.3     |
| **数组切片**   | `[start:end]`       | 数组切片       | v1.4     |
| **正则表达式** | `test()`, `match()` | 文本匹配       | v1.4     |
| **流式处理**   | `foreach`, `reduce` | 数据流控制     | v1.5     |

### 兼容性目标

#### 语法兼容性目标

- **v1.2**: 达到 70% jq 核心语法兼容性
- **v1.3**: 达到 85% jq 核心语法兼容性
- **v1.4**: 达到 95% jq 核心语法兼容性

#### 性能目标

- **解析性能**: 与 jq 相当或更好
- **执行性能**: 大多数情况下优于 jq
- **内存使用**: 控制在输入数据的 2-3 倍以内

## 实现策略

### Phase 1: 核心语法完善 (v1.2) ✅

- [x] 管道和逗号操作符
- [x] 条件表达式系统
- [x] 比较和逻辑操作符
- [x] 错误处理机制
- [x] 内置函数系统

### Phase 2: 高级功能扩展 (v1.3)

- [ ] 用户自定义函数
- [ ] 变量绑定和作用域
- [ ] 模块系统基础

### Phase 3: 生态系统完善 (v1.4+)

- [ ] 数组切片和字符串操作
- [ ] 正则表达式支持
- [ ] 性能优化和并行处理

## 兼容性测试策略

### jq 兼容性测试套件

```rust
// 基于 jq 官方测试用例的兼容性验证
#[test]
fn test_jq_compatibility_basic() {
    let test_cases = vec![
        (".foo", r#"{"foo": 42}"#, "42"),
        (".foo.bar", r#"{"foo": {"bar": "hello"}}"#, "\"hello\""),
        (".[]", r#"[1,2,3]"#, "1\n2\n3"),
        // ... 更多测试用例
    ];

    for (expr, input, expected) in test_cases {
        let result = xqpath_execute(expr, input);
        assert_eq!(result, expected);
    }
}
```

### 性能基准测试

```rust
// 与 jq 的性能对比测试
fn benchmark_vs_jq() {
    let test_data = generate_large_json(10000);
    let expressions = vec![
        ".users | map(.name)",
        ".users | select(.active) | length",
        // ... 更多表达式
    ];

    for expr in expressions {
        let xqpath_time = benchmark_xqpath(expr, &test_data);
        let jq_time = benchmark_jq(expr, &test_data);

        println!("Expression: {}", expr);
        println!("XQPath: {:?}, jq: {:?}", xqpath_time, jq_time);
    }
}
```

## 向前兼容性保证

### API 稳定性承诺

1. **解析器 API**: `parse_path_expression()` 函数签名保持稳定
2. **求值器 API**: `evaluate_path_expression()` 函数签名保持稳定
3. **错误类型**: 现有错误类型不会被移除，只会扩展
4. **语法支持**: 已支持的语法不会被移除或改变语义

### 废弃策略

1. **提前通知**: 功能废弃前至少提前一个大版本通知
2. **迁移指南**: 提供详细的迁移文档和工具
3. **过渡期**: 保持至少两个大版本的向后兼容

## 未解决的问题

### 设计决策

1. **数组切片语法**: 是否采用 Python 风格 `[start:end:step]` 还是保持 jq 风格？
2. **错误处理**: 是否完全模拟 jq 的错误处理行为？
3. **性能权衡**: 在哪些地方可以为了性能而偏离 jq 行为？

### 技术挑战

1. **流式处理**: 如何在保持内存效率的同时支持复杂的流式操作？
2. **类型系统**: 是否需要更强的类型检查来避免运行时错误？
3. **并发支持**: 如何安全地支持并行表达式求值？

## 参考资料

- [jq 官方文档](https://stedolan.github.io/jq/)
- [jq 语法参考](https://stedolan.github.io/jq/manual/)
- [XQPath v1.2 发布说明](../releases/v1.2-release-notes.md)

---

**变更历史**:

- 2025 年 7 月 27 日: 更新 v1.2 实现状态
- 2025 年 6 月: 初始版本
